"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@angular-devkit/core");
const schematics_1 = require("@angular-devkit/schematics");
const ast_utils_1 = require("@schematics/angular/utility/ast-utils");
const config_1 = require("@schematics/angular/utility/config");
const project_1 = require("@schematics/angular/utility/project");
const project_targets_1 = require("@schematics/angular/utility/project-targets");
const ts = require("typescript");
const utils_1 = require("./utils");
const BROWSER_DIST = 'dist/browser';
const SERVER_DIST = 'dist/server';
function updateConfigFile(options) {
    return (host) => {
        const workspace = config_1.getWorkspace(host);
        if (!workspace.projects[options.clientProject]) {
            throw new schematics_1.SchematicsException(`Client app ${options.clientProject} not found.`);
        }
        const clientProject = workspace.projects[options.clientProject];
        if (!clientProject.architect) {
            throw new Error('Client project architect not found.');
        }
        if (!clientProject.architect.server) {
            return;
        }
        clientProject.architect.server.configurations = {
            production: {
                fileReplacements: [
                    {
                        replace: 'src/environments/environment.ts',
                        with: 'src/environments/environment.prod.ts'
                    }
                ]
            }
        };
        clientProject.architect.server.options.outputPath = SERVER_DIST;
        clientProject.architect.build
            .options.outputPath = BROWSER_DIST;
        const workspacePath = config_1.getWorkspacePath(host);
        host.overwrite(workspacePath, JSON.stringify(workspace, null, 2));
        return host;
    };
}
exports.updateConfigFile = updateConfigFile;
function addModuleMapLoader(options) {
    return (host) => {
        const clientProject = project_1.getProject(host, options.clientProject);
        const clientTargets = project_targets_1.getProjectTargets(clientProject);
        if (!clientTargets.server) {
            return;
        }
        const mainPath = core_1.normalize('/' + clientTargets.server.options.main);
        const appServerModuleRelativePath = utils_1.findAppServerModulePath(host, mainPath);
        const modulePath = core_1.normalize(`/${clientProject.root}/src/${appServerModuleRelativePath}.ts`);
        let moduleSource = getTsSourceFile(host, modulePath);
        const importModule = 'ModuleMapLoaderModule';
        const importPath = '@nguniversal/module-map-ngfactory-loader';
        const moduleMapImportChange = ast_utils_1.insertImport(moduleSource, modulePath, importModule, importPath);
        if (moduleMapImportChange) {
            const recorder = host.beginUpdate(modulePath);
            recorder.insertLeft(moduleMapImportChange.pos, moduleMapImportChange.toAdd);
            host.commitUpdate(recorder);
        }
        const importText = 'ModuleMapLoaderModule';
        moduleSource = getTsSourceFile(host, modulePath);
        const metadataChanges = ast_utils_1.addSymbolToNgModuleMetadata(moduleSource, modulePath, 'imports', importText);
        if (metadataChanges) {
            const recorder = host.beginUpdate(modulePath);
            metadataChanges.forEach((change) => {
                recorder.insertRight(change.pos, change.toAdd);
            });
            host.commitUpdate(recorder);
        }
    };
}
exports.addModuleMapLoader = addModuleMapLoader;
function addExports(options) {
    return (host) => {
        const clientProject = project_1.getProject(host, options.clientProject);
        const clientTargets = project_targets_1.getProjectTargets(clientProject);
        if (!clientTargets.server) {
            return;
        }
        const mainPath = core_1.normalize('/' + clientTargets.server.options.main);
        const mainSourceFile = getTsSourceFile(host, mainPath);
        let mainText = utils_1.getTsSourceText(host, mainPath);
        const mainRecorder = host.beginUpdate(mainPath);
        const expressEngineExport = utils_1.generateExport(mainSourceFile, ['ngExpressEngine'], '@nguniversal/express-engine');
        const moduleMapExport = utils_1.generateExport(mainSourceFile, ['provideModuleMap'], '@nguniversal/module-map-ngfactory-loader');
        const exports = ast_utils_1.findNodes(mainSourceFile, ts.SyntaxKind.ExportDeclaration);
        const addedExports = `\n${expressEngineExport}\n${moduleMapExport}\n`;
        const exportChange = ast_utils_1.insertAfterLastOccurrence(exports, addedExports, mainText, 0);
        mainRecorder.insertLeft(exportChange.pos, exportChange.toAdd);
        host.commitUpdate(mainRecorder);
    };
}
exports.addExports = addExports;
function getTsSourceFile(host, path) {
    const buffer = host.read(path);
    if (!buffer) {
        throw new schematics_1.SchematicsException(`Could not read file (${path}).`);
    }
    const content = buffer.toString();
    const source = ts.createSourceFile(path, content, ts.ScriptTarget.Latest, true);
    return source;
}
